<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gārsecg</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: 'Arial', sans-serif;
    }

    canvas {
      display: block;
      background: #041E42;
      background-attachment: fixed;
    }

    #healthDiv {
      position: fixed;
      top: 10px;
      right: 10px;
      background-color: rgba(0, 0, 40, 0.7);
      color: #5CDBFF;
      padding: 10px 15px;
      font-family: 'Courier New', monospace;
      font-size: 20px;
      border-radius: 10px;
      border: 2px solid #5CDBFF;
      z-index: 1000;
      box-shadow: 0 0 10px #5CDBFF;
    }

    #gameTitle {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #5CDBFF;
      font-family: 'Courier New', monospace;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 0 0 10px #5CDBFF;
      z-index: 1000;
    }
  </style>
</head>

<body>
  <div id="gameTitle">Gārsecg</div>
  <div id="healthDiv">Health: 100%</div>
  <canvas id="gameCanvas"></canvas>
  <script type="module">
    // Import explosion effects and enemy/squid/triangle functions.
    import { startBubbleExplosion, updateBubbleExplosions } from "./bubbles.js";
    import { spawnEnemy, updateEnemies, spawnSquid, updateSquids, spawnTriangleEnemy, updateTriangleEnemies } from "./enemies.js";
    import { startDamageExplosion, updateDamageExplosions } from './damageEffect.js';

    // Import Rapier2D (compat version) from Skypack.
    const shotSound = new Audio("shot.wav"); // Ensure this file exists
    import * as RAPIER from "https://cdn.skypack.dev/@dimforge/rapier2d-compat";
    await RAPIER.init();

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // --- High-DPI resolution-independent canvas setup ---
    function updateCanvasResolution() {
      const dpr = window.devicePixelRatio || 1;
      // Set the canvas's internal dimensions to CSS size * dpr.
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      // Set CSS dimensions to window size.
      canvas.style.width = window.innerWidth + "px";
      canvas.style.height = window.innerHeight + "px";
      // Scale the drawing context so that 1 unit equals 1 CSS pixel.
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      // Optional: disable image smoothing for crisp lines.
      ctx.imageSmoothingEnabled = false;
    }
    // Initial call.
    updateCanvasResolution();
    // Also update on window resize.
    window.addEventListener("resize", updateCanvasResolution);
    // And monitor changes in devicePixelRatio (which may occur with zoom)
    let lastDPR = window.devicePixelRatio || 1;
    setInterval(() => {
      const currentDPR = window.devicePixelRatio || 1;
      if (currentDPR !== lastDPR) {
        updateCanvasResolution();
        lastDPR = currentDPR;
      }
    }, 250);

    // Game world and constants.
    const worldWidth = 1400;
    const worldHeight = 1400;
    const playerRadius = 20;
    const enemyRadius = 15;
    const bulletRadius = 5;
    const maxPlayerSpeed = 400;
    const bulletSpeed = 1000;
    const bulletLifetime = 1000;
    let playerHealth = 100;

    // Fire rate and dash control.
    const fireRate = 10; // bullets per second.
    const fireInterval = 1000 / fireRate;
    let lastShotTime = 0;
    let isShooting = false;
    let dashTriggered = false;

    // Create Rapier2D physics world (no gravity).
    const gravity = { x: 0, y: 0 };
    const physicsWorld = new RAPIER.World(gravity);

    // Arrays for enemies, squids, triangle enemies, and bullets.
    const enemies = [];
    const squids = [];
    const triangleEnemies = [];
    const bullets = [];

    // --- Create Walls ---
    const walls = [];
    function createWall(x, y, width, height) {
      const bodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(x, y);
      const wallBody = physicsWorld.createRigidBody(bodyDesc);
      const colliderDesc = RAPIER.ColliderDesc.cuboid(width / 2, height / 2);
      physicsWorld.createCollider(colliderDesc, wallBody);
      walls.push({ x, y, width, height });
    }
    // Four walls.
    createWall(worldWidth / 2, -50, worldWidth + 200, 100);
    createWall(worldWidth / 2, worldHeight + 50, worldWidth + 200, 100);
    createWall(-50, worldHeight / 2, 100, worldHeight + 200);
    createWall(worldWidth + 50, worldHeight / 2, 100, worldHeight + 200);

    // --- Create the Player ---
    const playerBodyDesc = RAPIER.RigidBodyDesc.dynamic()
      .setTranslation(worldWidth / 2, worldHeight / 2)
      .setCcdEnabled(true);
    const playerBody = physicsWorld.createRigidBody(playerBodyDesc);
    const playerColliderDesc = RAPIER.ColliderDesc.ball(playerRadius);
    physicsWorld.createCollider(playerColliderDesc, playerBody);

    // --- Spawn Regular Enemies ---
    for (let i = 0; i < 10; i++) {
      spawnEnemy({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, enemies });
    }

    // --- Spawn Squid Enemies ---
    for (let i = 0; i < 10; i++) {
      spawnSquid({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, squids });
    }

    // --- Spawn Triangle Enemies ---
    for (let i = 0; i < 0; i++) {
      spawnTriangleEnemy({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, triangleEnemies });
    }

    // --- Input Handling ---
    const keys = { w: false, a: false, s: false, d: false };
    window.addEventListener("keydown", (e) => {
      if (e.key === "w") keys.w = true;
      if (e.key === "a") keys.a = true;
      if (e.key === "s") keys.s = true;
      if (e.key === "d") keys.d = true;
      if (e.code === "Space") {
        if(!isDashing){
          dashTriggered = true;
        }
        e.preventDefault();
      }
    });
    window.addEventListener("keyup", (e) => {
      if (e.key === "w") keys.w = false;
      if (e.key === "a") keys.a = false;
      if (e.key === "s") keys.s = false;
      if (e.key === "d") keys.d = false;
    });

    // Mouse tracking for aiming.
    let lastMouseX = 0;
    let lastMouseY = 0;
    let canvasRect = canvas.getBoundingClientRect();

    window.addEventListener("resize", () => {
      canvasRect = canvas.getBoundingClientRect();
    });

    canvas.addEventListener("mousemove", (e) => {
      // Use the cached canvasRect value.
      lastMouseX = (e.clientX - canvasRect.left) * (canvas.width / canvasRect.width);
      lastMouseY = (e.clientY - canvasRect.top) * (canvas.height / canvasRect.height);
    });


    // Continuous firing and dash via mouse.
    canvas.addEventListener("mousedown", (e) => {
      if (e.button === 0) {
        isShooting = true;
      } else if (e.button === 2) {
        if(!isDashing){
          dashTriggered = true;
        }
        e.preventDefault();
      }
    });
    canvas.addEventListener("mouseup", () => {
      isShooting = false;
    });
    canvas.addEventListener("mouseleave", () => {
      isShooting = false;
    });
    canvas.addEventListener("contextmenu", (e) => {
      e.preventDefault();
    });

    // --- Camera Setup ---
    function getCameraScale() {
      return canvas.width / worldWidth;
    }
    function getCameraOrigin(playerPos, scale) {
      return {
        x: canvas.width / 2 - playerPos.x * scale,
        y: canvas.height / 2 - playerPos.y * scale,
      };
    }

    // --- Revised Movement Logic for the Player ---
    const movementLerp = 0.2;
    let isDashing = false;
    function updatePlayerMovement(dt) {
      if (dashTriggered) {
        isDashing = true; // Start dash
        setTimeout(() => {
          isDashing = false; // End dash after a short duration
        }, 1000);
        const playerPos = playerBody.translation();
        const scale = getCameraScale();
        const origin = getCameraOrigin(playerPos, scale);
        const worldMouseX = (lastMouseX - origin.x) / scale;
        const worldMouseY = (lastMouseY - origin.y) / scale;
        const dx = worldMouseX - playerPos.x;
        const dy = worldMouseY - playerPos.y;
        const len = Math.hypot(dx, dy);
        if (len > 0) {
          const normX = dx / len;
          const normY = dy / len;
          const dashSpeed = 5000;
          playerBody.setLinvel({ x: normX * dashSpeed, y: normY * dashSpeed }, true);
        }
        dashTriggered = false;
        return;
      }
      const currentVel = playerBody.linvel();
      let targetVel = { x: 0, y: 0 };
      if (keys.w || keys.a || keys.s || keys.d) {
        let inputX = 0, inputY = 0;
        if (keys.w) inputY -= 1;
        if (keys.s) inputY += 1;
        if (keys.a) inputX -= 1;
        if (keys.d) inputX += 1;
        const len = Math.hypot(inputX, inputY);
        if (len > 0) {
          inputX /= len;
          inputY /= len;
        }
        targetVel.x = inputX * maxPlayerSpeed;
        targetVel.y = inputY * maxPlayerSpeed;
      }
      const newVel = {
        x: currentVel.x + (targetVel.x - currentVel.x) * movementLerp,
        y: currentVel.y + (targetVel.y - currentVel.y) * movementLerp,
      };
      playerBody.setLinvel(newVel, true);
    }

    // --- Game Loop ---
    let lastTime = performance.now();
    function gameLoop(currentTime) {
      const dt = (currentTime - lastTime) / 1000;
      lastTime = currentTime;

      updatePlayerMovement(dt);
      physicsWorld.step();

      updateEnemies(enemies);
      updateSquids(squids, playerBody, currentTime, dt);
      updateTriangleEnemies(triangleEnemies, playerBody, dt);

      // --- Update Bullets ---
      for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        if (
          currentTime - bullet.birthTime > bulletLifetime ||
          bullet.body.translation().x < 0 ||
          bullet.body.translation().x > worldWidth ||
          bullet.body.translation().y < 0 ||
          bullet.body.translation().y > worldHeight
        ) {
          physicsWorld.removeRigidBody(bullet.body);
          bullets.splice(i, 1);
        }
      }

      // --- Check for Bullet–Regular Enemy Collisions ---
      const playerPos = playerBody.translation();
      for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        const bPos = bullet.body.translation();
        for (let j = enemies.length - 1; j >= 0; j--) {
          const enemy = enemies[j];
          const ePos = enemy.translation();
          if (Math.hypot(bPos.x - ePos.x, bPos.y - ePos.y) < bulletRadius + enemyRadius) {
            startBubbleExplosion(ePos.x, ePos.y);
            physicsWorld.removeRigidBody(enemy);
            enemies.splice(j, 1);
            physicsWorld.removeRigidBody(bullet.body);
            bullets.splice(i, 1);
            spawnEnemy({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, enemies });
            break;
          }
        }
      }

      // --- Check for Bullet–Squid Collisions ---
      for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        const bPos = bullet.body.translation();
        for (let j = squids.length - 1; j >= 0; j--) {
          const squid = squids[j];
          const sPos = squid.translation();
          if (Math.hypot(bPos.x - sPos.x, bPos.y - sPos.y) < bulletRadius + enemyRadius) {
            startBubbleExplosion(sPos.x, sPos.y);
            physicsWorld.removeRigidBody(squid);
            squids.splice(j, 1);
            physicsWorld.removeRigidBody(bullet.body);
            bullets.splice(i, 1);
            spawnSquid({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, squids });
            break;
          }
        }
      }

      // --- Check for Bullet–Triangle Enemy Collisions ---
      for (let i = triangleEnemies.length - 1; i >= 0; i--) {
        const tri = triangleEnemies[i];
        const triPos = tri.translation();
        for (let j = bullets.length - 1; j >= 0; j--) {
          const bullet = bullets[j];
          const bPos = bullet.body.translation();
          if (Math.hypot(bPos.x - triPos.x, bPos.y - triPos.y) < bulletRadius + enemyRadius) {
            startBubbleExplosion(triPos.x, triPos.y);
            physicsWorld.removeRigidBody(tri);
            triangleEnemies.splice(i, 1);
            physicsWorld.removeRigidBody(bullet.body);
            bullets.splice(j, 1);
            spawnTriangleEnemy({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, triangleEnemies });
            break;
          }
        }
      }

      // --- Check for Enemy–Player Collisions ---
      for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        const ePos = enemy.translation();
        if (Math.hypot(playerPos.x - ePos.x, playerPos.y - ePos.y) < playerRadius + enemyRadius) {
          startBubbleExplosion(ePos.x, ePos.y);
          // player can hit enemies when dashing. 
          if (!isDashing) {
            playerHealth -= 10;
            startDamageExplosion(playerPos.x, playerPos.y);
          }
          physicsWorld.removeRigidBody(enemy);
          enemies.splice(i, 1);
          spawnEnemy({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, enemies });
          if (playerHealth <= 0) {
            alert("Your submarine has been destroyed!");
            window.location.reload();
            return;
          }
        }
      }

      // --- Check for Squid–Player Collisions ---
      for (let i = squids.length - 1; i >= 0; i--) {
        const squid = squids[i];
        const sPos = squid.translation();
        if (Math.hypot(playerPos.x - sPos.x, playerPos.y - sPos.y) < playerRadius + enemyRadius) {
          startBubbleExplosion(sPos.x, sPos.y);
          if (!isDashing) {
            playerHealth -= 10;
            startDamageExplosion(playerPos.x, playerPos.y);
          }
          physicsWorld.removeRigidBody(squid);
          squids.splice(i, 1);
          spawnSquid({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, squids });
          if (playerHealth <= 0) {
            alert("Your submarine has been destroyed!");
            window.location.reload();
            return;
          }
        }
      }

      // --- Check for Triangle Enemy–Player Collisions ---
      for (let i = triangleEnemies.length - 1; i >= 0; i--) {
        const tri = triangleEnemies[i];
        const triPos = tri.translation();
        if (Math.hypot(playerPos.x - triPos.x, playerPos.y - triPos.y) < playerRadius + enemyRadius) {
          startBubbleExplosion(triPos.x, triPos.y);
          if (!isDashing) {
            playerHealth -= 10;
            startDamageExplosion(playerPos.x, playerPos.y);
          }
          physicsWorld.removeRigidBody(tri);
          triangleEnemies.splice(i, 1);
          spawnTriangleEnemy({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, triangleEnemies });
          if (playerHealth <= 0) {
            alert("Your submarine has been destroyed!");
            window.location.reload();
            return;
          }
        }
      }

      // --- Fire Bullet Continuously in Ship’s Facing Direction ---
      if (isShooting && currentTime - lastShotTime > fireInterval) {
        lastShotTime = currentTime;
        const playerPos = playerBody.translation();
        const shipAngle = playerBody.rotation();
        const gunOffset = playerRadius + 10;
        const bulletStartX = playerPos.x + Math.cos(shipAngle) * gunOffset;
        const bulletStartY = playerPos.y + Math.sin(shipAngle) * gunOffset;
        const bulletBodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(bulletStartX, bulletStartY);
        const bulletBody = physicsWorld.createRigidBody(bulletBodyDesc);
        const bulletColliderDesc = RAPIER.ColliderDesc.ball(bulletRadius);
        physicsWorld.createCollider(bulletColliderDesc, bulletBody);
        bulletBody.setLinvel({
          x: Math.cos(shipAngle) * bulletSpeed,
          y: Math.sin(shipAngle) * bulletSpeed
        }, true);
        const soundClone = shotSound.cloneNode();
        soundClone.volume = 0.02; // Adjust volume as needed
        soundClone.play();
        bullets.push({ body: bulletBody, birthTime: currentTime });
      }

      // --- Update Player Rotation to Face the Mouse ---
      if (lastMouseX || lastMouseY) {
        const scale = getCameraScale();
        const origin = getCameraOrigin(playerPos, scale);
        const worldMouseX = (lastMouseX - origin.x) / scale;
        const worldMouseY = (lastMouseY - origin.y) / scale;
        const targetAngle = Math.atan2(worldMouseY - playerPos.y, worldMouseX - playerPos.x);
        const currentAngle = playerBody.rotation();
        let angleDiff = Math.atan2(Math.sin(targetAngle - currentAngle), Math.cos(targetAngle - currentAngle));
        const angularPushFactor = 10;
        const angularVelocity = angleDiff * angularPushFactor;
        playerBody.setAngvel(angularVelocity, true);
      }

      // --- Render Scene ---
      const scale = getCameraScale();
      const origin = getCameraOrigin(playerPos, scale);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.setTransform(scale, 0, 0, scale, origin.x, origin.y);
      ctx.beginPath();
      ctx.strokeStyle = "rgba(92, 219, 255, 0.2)";
      ctx.lineWidth = 1 / scale;
      const gridSize = 50;
      for (let x = 0; x <= worldWidth; x += gridSize) {
        ctx.moveTo(x, 0);
        ctx.lineTo(x, worldHeight);
      }
      for (let y = 0; y <= worldHeight; y += gridSize) {
        ctx.moveTo(0, y);
        ctx.lineTo(worldWidth, y);
      }
      ctx.stroke();

      ctx.fillStyle = "#143642";
      walls.forEach(w => {
        ctx.fillRect(w.x - w.width / 2, w.y - w.height / 2, w.width, w.height);
      });

      // --- Draw the Player ---
      function drawPlayer() {
        const playerPos = playerBody.translation();
        const angle = playerBody.rotation();
        ctx.save();
        ctx.translate(playerPos.x, playerPos.y);
        ctx.rotate(angle);
        if (isDashing) {
          ctx.globalAlpha = 0.5; // Semi-transparent
          ctx.fillStyle = "#5CDBFF";
          ctx.beginPath();
          ctx.arc(0, 0, playerRadius * 1.5, 0, Math.PI * 2);
          ctx.fill();

          ctx.globalAlpha = 1; // Reset opacity
        }
        ctx.fillStyle = "#FFCB05";
        ctx.beginPath();
        ctx.arc(0, 0, playerRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#E6B800";
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(-playerRadius * 1.8, -playerRadius * 0.2, -playerRadius * 0.8, -playerRadius * 0.8);
        ctx.quadraticCurveTo(-playerRadius * 0.4, -playerRadius * 0.4, 0, 0);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(-playerRadius * 1.8, playerRadius * 0.2, -playerRadius * 0.8, playerRadius * 0.8);
        ctx.quadraticCurveTo(-playerRadius * 0.4, playerRadius * 0.4, 0, 0);
        ctx.fill();
        ctx.fillStyle = "#E6B800";
        ctx.beginPath();
        ctx.moveTo(-playerRadius * 0.8, 0);
        ctx.lineTo(-playerRadius * 1.4, -playerRadius * 0.3);
        ctx.lineTo(-playerRadius * 1.6, 0);
        ctx.lineTo(-playerRadius * 1.4, playerRadius * 0.3);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = "#5DADE2";
        ctx.beginPath();
        ctx.arc(playerRadius * 0.4, 0, playerRadius * 0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#333333";
        for (let i = 0; i < 5; i++) {
          const angle = (i / 5) * Math.PI;
          ctx.beginPath();
          ctx.arc(Math.cos(angle) * playerRadius * 0.7, Math.sin(angle) * playerRadius * 0.7, 2, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.strokeStyle = "#FFCB05";
        ctx.lineWidth = 6 / scale;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        const turretAngle = 0;
        ctx.lineTo(Math.cos(turretAngle) * (playerRadius + 10), Math.sin(turretAngle) * (playerRadius + 10));
        ctx.stroke();
        ctx.fillStyle = "#333333";
        ctx.beginPath();
        ctx.arc(playerRadius + 10, 0, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
      drawPlayer();

      // --- Draw Regular Enemies ---
      ctx.fillStyle = "#FF4858";
      enemies.forEach(enemy => {
        const pos = enemy.translation();
        const vel = enemy.linvel();
        const enemyAngle = Math.atan2(vel.y, vel.x);
        ctx.save();
        ctx.translate(pos.x, pos.y);
        ctx.rotate(enemyAngle);
        const primaryColor = "#FF4858";
        const secondaryColor = "#CC3C4A";
        ctx.fillStyle = primaryColor;
        ctx.beginPath();
        const hexRadius = enemyRadius * 1.2;
        ctx.moveTo(hexRadius, 0);
        for (let i = 1; i <= 6; i++) {
          const angle = (Math.PI / 3) * i;
          ctx.lineTo(hexRadius * Math.cos(angle), hexRadius * Math.sin(angle));
        }
        ctx.fill();
        ctx.fillStyle = secondaryColor;
        ctx.beginPath();
        ctx.moveTo(-hexRadius, 0);
        ctx.lineTo(-hexRadius * 1.6, -hexRadius * 0.5);
        ctx.lineTo(-hexRadius * 2, 0);
        ctx.lineTo(-hexRadius * 1.6, hexRadius * 0.5);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = secondaryColor;
        ctx.beginPath();
        ctx.moveTo(-hexRadius * 0.5, -hexRadius * 0.8);
        ctx.lineTo(0, -hexRadius * 1.4);
        ctx.lineTo(hexRadius * 0.5, -hexRadius * 0.8);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(-hexRadius * 0.5, hexRadius * 0.8);
        ctx.lineTo(0, hexRadius * 1.4);
        ctx.lineTo(hexRadius * 0.5, hexRadius * 0.8);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(0, -hexRadius * 0.6);
        ctx.lineTo(hexRadius * 0.4, 0);
        ctx.lineTo(0, hexRadius * 0.6);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = "#FFFFFF";
        ctx.beginPath();
        ctx.arc(hexRadius * 0.6, -hexRadius * 0.3, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(hexRadius * 0.6, hexRadius * 0.3, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#000000";
        ctx.beginPath();
        ctx.arc(hexRadius * 0.6, -hexRadius * 0.3, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(hexRadius * 0.6, hexRadius * 0.3, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = secondaryColor;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(hexRadius * 0.3, -hexRadius * 0.5);
        ctx.lineTo(hexRadius * 0.3, hexRadius * 0.5);
        ctx.stroke();
        ctx.restore();
      });

      // --- Draw Squid Enemies ---
      squids.forEach(squid => {
        const pos = squid.translation();
        const angle = squid.rotation();
        ctx.save();
        ctx.translate(pos.x, pos.y);
        ctx.rotate(angle);
        ctx.fillStyle = "#8A2BE2";
        ctx.beginPath();
        ctx.arc(0, 0, enemyRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#FFFFFF";
        ctx.beginPath();
        const dotX = enemyRadius * 0.7;
        ctx.arc(dotX, 0, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });

      // --- Draw Triangle Enemies ---
      triangleEnemies.forEach(tri => {
        const pos = tri.translation();
        const angle = tri.rotation();
        ctx.save();
        ctx.translate(pos.x, pos.y);
        ctx.rotate(angle);
        ctx.beginPath();
        // Draw a triangle with its tip at the right.
        const size = enemyRadius; // triangle size
        ctx.moveTo(size, 0);
        ctx.lineTo(-size, -size * 0.7);
        ctx.lineTo(-size, size * 0.7);
        ctx.closePath();
        ctx.fillStyle = "black";
        ctx.fill();
        ctx.strokeStyle = "red";
        ctx.lineWidth = 2 / scale;
        ctx.stroke();
        ctx.restore();
      });

      // --- Draw Bullets ---
      ctx.fillStyle = "#5CDBFF";
      bullets.forEach(bullet => {
        const pos = bullet.body.translation();
        const vel = bullet.body.linvel();
        const bulletAngle = Math.atan2(vel.y, vel.x);
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, bulletRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.strokeStyle = "rgba(92, 219, 255, 0.6)";
        ctx.lineWidth = bulletRadius / scale;
        const trailLength = 10;
        ctx.moveTo(pos.x, pos.y);
        ctx.lineTo(
          pos.x - Math.cos(bulletAngle) * trailLength,
          pos.y - Math.sin(bulletAngle) * trailLength
        );
        ctx.stroke();
      });

      // Draw explosion effects.
      updateBubbleExplosions(ctx, scale, getCameraOrigin(playerPos, scale));
      updateDamageExplosions(ctx, scale, getCameraOrigin(playerPos, scale));


      // Reset transform for HUD.
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      document.getElementById("healthDiv").innerText = "Health: " + playerHealth + "%";

      requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);

    window.addEventListener("resize", () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });
  </script>
</body>

</html>
