<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gārsecg</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      /* background: #000; */
      background: #041E42;

      font-family: 'Arial', sans-serif;
    }

    canvas {
      display: block;
      /* background: #041E42; */
      background-attachment: fixed;
    }

    #healthDiv {
      position: fixed;
      top: 10px;
      right: 10px;
      background-color: rgba(0, 0, 40, 0.7);
      color: #5CDBFF;
      padding: 10px 15px;
      font-family: 'Courier New', monospace;
      font-size: 20px;
      border-radius: 10px;
      border: 2px solid #5CDBFF;
      z-index: 1000;
      box-shadow: 0 0 10px #5CDBFF;
    }

    #gameTitle {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #5CDBFF;
      font-family: 'Courier New', monospace;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 0 0 10px #5CDBFF;
      z-index: 1000;
    }

    /* Modal Styles */
    #modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    #modalContent {
      background: #041E42;
      padding: 20px;
      border: 2px solid #5CDBFF;
      border-radius: 10px;
      color: #5CDBFF;
      font-family: 'Courier New', monospace;
      text-align: center;
      width: 80%;
      max-width: 600px;
    }

    #modal button {
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 18px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background-color: #5CDBFF;
      color: #041E42;
    }
  </style>
</head>

<body>
  <div id="gameTitle">Gārsecg (Alpha Version)</div>
  <div id="healthDiv">Health: 100% | Score: 0</div>
  <canvas id="gameCanvas"></canvas>

  <!-- Modal Popup -->
  <div id="modal">
    <div id="modalContent">
      <h1>Welcome to Gārsecg</h1>
      <p><strong>Instructions:</strong> Use WASD to move your submarine and your mouse to aim. Left click to shoot and
        right click (or Space) to dash.</p>
      <p>Survive as long as you can and score by destroying enemies!</p>
      <button id="beginButton">Begin</button>
    </div>
  </div>

  <script type="module">
    // Import explosion effects and enemy/squid/triangle functions.
    import { startBubbleExplosion, updateBubbleExplosions } from "./bubbles.js";
    import { spawnEnemy, updateEnemies, spawnSquid, updateSquids, spawnTriangleEnemy, updateTriangleEnemies } from "./enemies.js";
    import { startDamageExplosion, updateDamageExplosions } from './damageEffect.js';
    import { renderScene } from "./renderScene.js"

    // Import Rapier2D (compat version) from Skypack.
    const shotSound = new Audio("shot.wav"); // Ensure this file exists
    import * as RAPIER from "https://cdn.skypack.dev/@dimforge/rapier2d-compat";
    await RAPIER.init();

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // --- High-DPI resolution-independent canvas setup ---
    function updateCanvasResolution() {
      const dpr = window.devicePixelRatio || 1;
      // Set internal dimensions based on CSS size * dpr.
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      // Set CSS dimensions to window size.
      canvas.style.width = window.innerWidth + "px";
      canvas.style.height = window.innerHeight + "px";
      // Scale the drawing context.
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.imageSmoothingEnabled = false;
    }
    updateCanvasResolution();
    window.addEventListener("resize", updateCanvasResolution);
    let lastDPR = window.devicePixelRatio || 1;
    setInterval(() => {
      const currentDPR = window.devicePixelRatio || 1;
      if (currentDPR !== lastDPR) {
        updateCanvasResolution();
        lastDPR = currentDPR;
      }
    }, 250);

    // Also include the working resize listener from your baseline code.
    window.addEventListener("resize", () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });

    // Game world and constants.
    const worldWidth = 1400;
    const worldHeight = 1400;
    const playerRadius = 20;
    const enemyRadius = 15;
    const bulletRadius = 5;
    const maxPlayerSpeed = 400;
    const bulletSpeed = 1000;
    const bulletLifetime = 1000;
    let playerHealth = 100;
    let score = 0;

    // Fire rate and dash control.
    const fireRate = 10; // bullets per second.
    const fireInterval = 1000 / fireRate;
    let lastShotTime = 0;
    let isShooting = false;
    let dashTriggered = false;

    // Create Rapier2D physics world (no gravity).
    const gravity = { x: 0, y: 0 };
    const physicsWorld = new RAPIER.World(gravity);

    // Arrays for enemies, squids, triangle enemies, and bullets.
    const enemies = [];
    const squids = [];
    const triangleEnemies = [];
    const bullets = [];

    // --- Create Walls ---
    const walls = [];
    function createWall(x, y, width, height) {
      const bodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(x, y);
      const wallBody = physicsWorld.createRigidBody(bodyDesc);
      const colliderDesc = RAPIER.ColliderDesc.cuboid(width / 2, height / 2);
      physicsWorld.createCollider(colliderDesc, wallBody);
      walls.push({ x, y, width, height });
    }
    // Four walls.
    createWall(worldWidth / 2, -50, worldWidth + 200, 100);
    createWall(worldWidth / 2, worldHeight + 50, worldWidth + 200, 100);
    createWall(-50, worldHeight / 2, 100, worldHeight + 200);
    createWall(worldWidth + 50, worldHeight / 2, 100, worldHeight + 200);

    // --- Create the Player ---
    const playerBodyDesc = RAPIER.RigidBodyDesc.dynamic()
      .setTranslation(worldWidth / 2, worldHeight / 2)
      .setCcdEnabled(true);
    const playerBody = physicsWorld.createRigidBody(playerBodyDesc);
    const playerColliderDesc = RAPIER.ColliderDesc.ball(playerRadius);
    physicsWorld.createCollider(playerColliderDesc, playerBody);

    //enemy spawn loop
    setInterval(() => {
      if (gameStarted) {
        spawnEnemy({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, enemies });

        spawnSquid({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, squids });

        spawnTriangleEnemy({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, triangleEnemies });

        // spawnSquid({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, squids });
        // spawnSquid({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, squids });


      }

    }, 1000)

    // --- Spawn Regular Enemies ---
    for (let i = 0; i < 10; i++) {
      spawnEnemy({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, enemies });
    }

    // --- Spawn Squid Enemies ---
    for (let i = 0; i < 10; i++) {
      spawnSquid({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, squids });
    }

    // --- Spawn Triangle Enemies ---
    for (let i = 0; i < 0; i++) {
      spawnTriangleEnemy({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, triangleEnemies });
    }

    // --- Input Handling ---
    const keys = { w: false, a: false, s: false, d: false };
    window.addEventListener("keydown", (e) => {
      if (e.key === "w") keys.w = true;
      if (e.key === "a") keys.a = true;
      if (e.key === "s") keys.s = true;
      if (e.key === "d") keys.d = true;
      if (e.code === "Space") {
        if (!isDashing) {
          dashTriggered = true;
        }
        e.preventDefault();
      }
    });
    window.addEventListener("keyup", (e) => {
      if (e.key === "w") keys.w = false;
      if (e.key === "a") keys.a = false;
      if (e.key === "s") keys.s = false;
      if (e.key === "d") keys.d = false;
    });

    // Mouse tracking for aiming.
    let lastMouseX = 0;
    let lastMouseY = 0;
    let canvasRect = canvas.getBoundingClientRect();
    window.addEventListener("resize", () => {
      canvasRect = canvas.getBoundingClientRect();
    });
    canvas.addEventListener("mousemove", (e) => {
      lastMouseX = (e.clientX - canvasRect.left) * (canvas.width / canvasRect.width);
      lastMouseY = (e.clientY - canvasRect.top) * (canvas.height / canvasRect.height);
    });

    // Continuous firing and dash via mouse.
    canvas.addEventListener("mousedown", (e) => {
      if (e.button === 0) {
        isShooting = true;
      } else if (e.button === 2) {
        if (!isDashing) {
          dashTriggered = true;
        }
        e.preventDefault();
      }
    });
    canvas.addEventListener("mouseup", () => {
      isShooting = false;
    });
    canvas.addEventListener("mouseleave", () => {
      isShooting = false;
    });
    canvas.addEventListener("contextmenu", (e) => {
      e.preventDefault();
    });

    // --- Camera Setup ---
    function getCameraScale() {
      return canvas.width / worldWidth;
    }
    function getCameraOrigin(playerPos, scale) {
      return {
        x: canvas.width / 2 - playerPos.x * scale,
        y: canvas.height / 2 - playerPos.y * scale,
      };
    }

    // --- Revised Movement Logic for the Player ---
    const movementLerp = 0.2;
    let isDashing = false;
    function updatePlayerMovement(dt) {
      if (dashTriggered) {
        isDashing = true;
        setTimeout(() => {
          isDashing = false;
        }, 1000);
        const playerPos = playerBody.translation();
        const scale = getCameraScale();
        const origin = getCameraOrigin(playerPos, scale);
        const worldMouseX = (lastMouseX - origin.x) / scale;
        const worldMouseY = (lastMouseY - origin.y) / scale;
        const dx = worldMouseX - playerPos.x;
        const dy = worldMouseY - playerPos.y;
        const len = Math.hypot(dx, dy);
        if (len > 0) {
          const normX = dx / len;
          const normY = dy / len;
          const dashSpeed = 5000;
          playerBody.setLinvel({ x: normX * dashSpeed, y: normY * dashSpeed }, true);
        }
        dashTriggered = false;
        return;
      }
      const currentVel = playerBody.linvel();
      let targetVel = { x: 0, y: 0 };
      if (keys.w || keys.a || keys.s || keys.d) {
        let inputX = 0, inputY = 0;
        if (keys.w) inputY -= 1;
        if (keys.s) inputY += 1;
        if (keys.a) inputX -= 1;
        if (keys.d) inputX += 1;
        const len = Math.hypot(inputX, inputY);
        if (len > 0) {
          inputX /= len;
          inputY /= len;
        }
        targetVel.x = inputX * maxPlayerSpeed;
        targetVel.y = inputY * maxPlayerSpeed;
      }
      const newVel = {
        x: currentVel.x + (targetVel.x - currentVel.x) * movementLerp,
        y: currentVel.y + (targetVel.y - currentVel.y) * movementLerp,
      };
      playerBody.setLinvel(newVel, true);
    }

    // --- Modal and Game Start/Restart Logic ---
    let gameStarted = false;
    const modal = document.getElementById("modal");
    const modalContent = document.getElementById("modalContent");
    const beginButton = document.getElementById("beginButton");
    beginButton.addEventListener("click", () => {
      gameStarted = true;
      modal.style.display = "none";
    });

    function endGame() {
      gameStarted = false;
      modalContent.innerHTML = `
        <h1>Game Over</h1>
        <p>Your Score: ${score}</p>
        <button id="playAgain">Play Again</button>
      `;
      document.getElementById("playAgain").addEventListener("click", () => {
        location.reload();
      });
      modal.style.display = "flex";
    }

    // --- Game Loop ---
    let lastTime = performance.now();
    let time = 0;
    function gameLoop(currentTime) {
      time += 16
      if (!gameStarted) {
        requestAnimationFrame(gameLoop);
        return;
      }
      const dt = (currentTime - lastTime) / 1000;
      lastTime = currentTime;

      updatePlayerMovement(dt);
      physicsWorld.step();

      updateEnemies(enemies);
      updateSquids(squids, playerBody, currentTime, dt);
      updateTriangleEnemies(triangleEnemies, playerBody, dt);

      // --- Update Bullets ---
      for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        if (
          currentTime - bullet.birthTime > bulletLifetime ||
          bullet.body.translation().x < 0 ||
          bullet.body.translation().x > worldWidth ||
          bullet.body.translation().y < 0 ||
          bullet.body.translation().y > worldHeight
        ) {
          physicsWorld.removeRigidBody(bullet.body);
          bullets.splice(i, 1);
        }
      }

      const playerPos = playerBody.translation();
      // --- Check for Bullet–Regular Enemy Collisions ---
      for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        const bPos = bullet.body.translation();
        for (let j = enemies.length - 1; j >= 0; j--) {
          const enemy = enemies[j];
          const ePos = enemy.translation();
          if (Math.hypot(bPos.x - ePos.x, bPos.y - ePos.y) < bulletRadius + enemyRadius) {
            startBubbleExplosion(ePos.x, ePos.y);
            physicsWorld.removeRigidBody(enemy);
            enemies.splice(j, 1);
            physicsWorld.removeRigidBody(bullet.body);
            bullets.splice(i, 1);
            // spawnEnemy({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, enemies });
            score += 10;
            break;
          }
        }
      }

      // --- Check for Bullet–Squid Collisions ---
      for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        const bPos = bullet.body.translation();
        for (let j = squids.length - 1; j >= 0; j--) {
          const squid = squids[j];
          const sPos = squid.translation();
          if (Math.hypot(bPos.x - sPos.x, bPos.y - sPos.y) < bulletRadius + enemyRadius) {
            startBubbleExplosion(sPos.x, sPos.y);
            physicsWorld.removeRigidBody(squid);
            squids.splice(j, 1);
            physicsWorld.removeRigidBody(bullet.body);
            bullets.splice(i, 1);
            // spawnSquid({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, squids });
            score += 10;
            break;
          }
        }
      }

      // --- Check for Bullet–Triangle Enemy Collisions ---
      for (let i = triangleEnemies.length - 1; i >= 0; i--) {
        const tri = triangleEnemies[i];
        const triPos = tri.translation();
        for (let j = bullets.length - 1; j >= 0; j--) {
          const bullet = bullets[j];
          const bPos = bullet.body.translation();
          if (Math.hypot(bPos.x - triPos.x, bPos.y - triPos.y) < bulletRadius + enemyRadius) {
            startBubbleExplosion(triPos.x, triPos.y);
            physicsWorld.removeRigidBody(tri);
            triangleEnemies.splice(i, 1);
            physicsWorld.removeRigidBody(bullet.body);
            bullets.splice(j, 1);
            // spawnTriangleEnemy({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, triangleEnemies });
            score += 10;
            break;
          }
        }
      }

      // --- Check for Enemy–Player Collisions ---
      for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        const ePos = enemy.translation();
        if (Math.hypot(playerPos.x - ePos.x, playerPos.y - ePos.y) < playerRadius + enemyRadius) {
          startBubbleExplosion(ePos.x, ePos.y);
          if (!isDashing) {
            playerHealth -= 10;
            startDamageExplosion(playerPos.x, playerPos.y);
          }
          physicsWorld.removeRigidBody(enemy);
          enemies.splice(i, 1);
          // spawnEnemy({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, enemies });
          if (playerHealth <= 0) {
            endGame();
            return;
          }
        }
      }

      // --- Check for Squid–Player Collisions ---
      for (let i = squids.length - 1; i >= 0; i--) {
        const squid = squids[i];
        const sPos = squid.translation();
        if (Math.hypot(playerPos.x - sPos.x, playerPos.y - sPos.y) < playerRadius + enemyRadius) {
          startBubbleExplosion(sPos.x, sPos.y);
          if (!isDashing) {
            playerHealth -= 10;
            startDamageExplosion(playerPos.x, playerPos.y);
          }
          physicsWorld.removeRigidBody(squid);
          squids.splice(i, 1);
          // spawnSquid({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, squids });
          if (playerHealth <= 0) {
            endGame();
            return;
          }
        }
      }

      // --- Check for Triangle Enemy–Player Collisions ---
      for (let i = triangleEnemies.length - 1; i >= 0; i--) {
        const tri = triangleEnemies[i];
        const triPos = tri.translation();
        if (Math.hypot(playerPos.x - triPos.x, playerPos.y - triPos.y) < playerRadius + enemyRadius) {
          startBubbleExplosion(triPos.x, triPos.y);
          if (!isDashing) {
            playerHealth -= 10;
            startDamageExplosion(playerPos.x, playerPos.y);
          }
          physicsWorld.removeRigidBody(tri);
          triangleEnemies.splice(i, 1);
          // spawnTriangleEnemy({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, triangleEnemies });
          if (playerHealth <= 0) {
            endGame();
            return;
          }
        }
      }

      // --- Fire Bullet Continuously in Ship’s Facing Direction ---
      if (isShooting && currentTime - lastShotTime > fireInterval) {
        lastShotTime = currentTime;
        const playerPos = playerBody.translation();
        const shipAngle = playerBody.rotation();
        const gunOffset = playerRadius + 10;
        const bulletStartX = playerPos.x + Math.cos(shipAngle) * gunOffset;
        const bulletStartY = playerPos.y + Math.sin(shipAngle) * gunOffset;
        const bulletBodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(bulletStartX, bulletStartY);
        const bulletBody = physicsWorld.createRigidBody(bulletBodyDesc);
        const bulletColliderDesc = RAPIER.ColliderDesc.ball(bulletRadius);
        physicsWorld.createCollider(bulletColliderDesc, bulletBody);
        bulletBody.setLinvel({
          x: Math.cos(shipAngle) * bulletSpeed,
          y: Math.sin(shipAngle) * bulletSpeed
        }, true);
        const soundClone = shotSound.cloneNode();
        soundClone.volume = 0.02;
        soundClone.play();
        bullets.push({ body: bulletBody, birthTime: currentTime });
      }

      // --- Update Player Rotation to Face the Mouse ---
      if (lastMouseX || lastMouseY) {
        const scale = getCameraScale();
        const origin = getCameraOrigin(playerPos, scale);
        const worldMouseX = (lastMouseX - origin.x) / scale;
        const worldMouseY = (lastMouseY - origin.y) / scale;
        const targetAngle = Math.atan2(worldMouseY - playerPos.y, worldMouseX - playerPos.x);
        const currentAngle = playerBody.rotation();
        let angleDiff = Math.atan2(Math.sin(targetAngle - currentAngle), Math.cos(targetAngle - currentAngle));
        const angularPushFactor = 10;
        const angularVelocity = angleDiff * angularPushFactor;
        playerBody.setAngvel(angularVelocity, true);
      }

      renderScene({
        ctx,
        canvas,
        worldWidth,
        worldHeight,
        walls,
        playerBody,
        isDashing,
        playerRadius,
        enemies,
        enemyRadius,
        squids,
        triangleEnemies,
        bullets,
        bulletRadius,
        getCameraScale,
        getCameraOrigin,
        updateBubbleExplosions,
        updateDamageExplosions,
        time
      });



      document.getElementById("healthDiv").innerText = "Health: " + playerHealth + "% | Score: " + score;

      requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);
  </script>
</body>

</html>