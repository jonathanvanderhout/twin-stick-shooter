<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gārsecg</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #041E42;
      font-family: 'Arial', sans-serif;
    }

    canvas {
      display: block;
      background-attachment: fixed;
    }

    #healthDiv {
      position: fixed;
      top: 10px;
      right: 10px;
      background-color: rgba(0, 0, 40, 0.7);
      color: #5CDBFF;
      padding: 10px 15px;
      font-family: 'Courier New', monospace;
      font-size: 20px;
      border-radius: 10px;
      border: 2px solid #5CDBFF;
      z-index: 1000;
      box-shadow: 0 0 10px #5CDBFF;
    }

    #gameTitle {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #5CDBFF;
      font-family: 'Courier New', monospace;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 0 0 10px #5CDBFF;
      z-index: 1000;
    }

    /* Modal Styles */
    #modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    #modalContent {
      background: #041E42;
      padding: 20px;
      border: 2px solid #5CDBFF;
      border-radius: 10px;
      color: #5CDBFF;
      font-family: 'Courier New', monospace;
      text-align: center;
      width: 80%;
      max-width: 600px;
    }

    /* Existing button style */
    #modal button {
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 18px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background-color: #5CDBFF;
      color: #041E42;
    }

    /* New style for the fullscreen button */
    #fullscreenButton {
      background-color: orange;
      color: #041E42;
    }

    #gameTitle,
    #healthDiv {
      pointer-events: none;
      opacity: 0.7;
      /* Adjust the value as needed */
    }
  </style>
</head>

<body>
  <div id="gameTitle">Gārsecg (Alpha Version)</div>
  <div id="healthDiv">Health: 100% | Score: 0</div>
  <canvas id="gameCanvas"></canvas>

  <!-- Modal Popup -->
  <div id="modal">
    <div id="modalContent">
      <h1>Welcome to Gārsecg</h1>
      <p><strong>Instructions:</strong> Use WASD to move your submarine and your mouse to aim. Left click to shoot and
        right click (or Space) to dash.</p>
      <p>c will toggle the camera: follow ship or center game</p>
      <!-- Replacing the full screen message with a button -->
      <button id="fullscreenButton">Go Full Screen</button>
      <p>Survive as long as you can and score by destroying enemies!</p>
      <button id="beginButton">Begin</button>
    </div>
  </div>

  <script type="module">
    // Import explosion effects and enemy/squid/triangle functions.
    import { startBubbleExplosion, updateBubbleExplosions } from "./bubbles.js";
    import { spawnEnemy, updateEnemies, spawnSquid, updateSquids, spawnTriangleEnemy, updateTriangleEnemies } from "./enemies.js";
    import { startDamageExplosion, updateDamageExplosions } from './damageEffect.js';
    import { renderScene } from "./renderScene.js"

    // Import Rapier2D (compat version) from Skypack.
    const shotSound = new Audio("shot.wav"); // Ensure this file exists
    import * as RAPIER from "https://cdn.skypack.dev/@dimforge/rapier2d-compat";
    await RAPIER.init();

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // --- High-DPI resolution-independent canvas setup ---
    function updateCanvasResolution() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      canvas.style.width = window.innerWidth + "px";
      canvas.style.height = window.innerHeight + "px";
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.imageSmoothingEnabled = false;
    }
    updateCanvasResolution();
    window.addEventListener("resize", updateCanvasResolution);
    let lastDPR = window.devicePixelRatio || 1;
    setInterval(() => {
      const currentDPR = window.devicePixelRatio || 1;
      if (currentDPR !== lastDPR) {
        updateCanvasResolution();
        lastDPR = currentDPR;
      }
    }, 250);
    window.addEventListener("resize", () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });

    // Game world and constants.
    const worldWidth = 1920;
    const worldHeight = 1080;
    const playerRadius = 20;
    const enemyRadius = 15;
    const bulletRadius = 5;
    const maxPlayerSpeed = 400;
    const bulletSpeed = 1000;
    const bulletLifetime = 1000;
    let playerHealth = 100;
    let score = 0;

    // Fire rate and dash control.
    const fireRate = 10;
    const fireInterval = 1000 / fireRate;
    let lastShotTime = 0;
    let isShooting = false;
    let dashTriggered = false;

    // Create Rapier2D physics world (no gravity).
    const gravity = { x: 0, y: 0 };
    const physicsWorld = new RAPIER.World(gravity);

    // Arrays for enemies, squids, triangle enemies, and bullets.
    const enemies = [];
    const squids = [];
    const triangleEnemies = [];
    const bullets = [];

    // --- Create Walls ---
    const walls = [];
    function createWall(x, y, width, height) {
      const bodyDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(x, y);
      const wallBody = physicsWorld.createRigidBody(bodyDesc);
      const colliderDesc = RAPIER.ColliderDesc.cuboid(width / 2, height / 2);
      physicsWorld.createCollider(colliderDesc, wallBody);
      walls.push({ x, y, width, height });
    }
    createWall(worldWidth / 2, -50, worldWidth + 200, 100);
    createWall(worldWidth / 2, worldHeight + 50, worldWidth + 200, 100);
    createWall(-50, worldHeight / 2, 100, worldHeight + 200);
    createWall(worldWidth + 50, worldHeight / 2, 100, worldHeight + 200);

    // --- Create the Player ---
    const playerBodyDesc = RAPIER.RigidBodyDesc.dynamic()
      .setTranslation(worldWidth / 2, worldHeight / 2)
      .setCcdEnabled(true);
    const playerBody = physicsWorld.createRigidBody(playerBodyDesc);
    const playerColliderDesc = RAPIER.ColliderDesc.ball(playerRadius);
    physicsWorld.createCollider(playerColliderDesc, playerBody);

    // Enemy spawn loop.
  // Import the gamePlan configuration.
import gamePlan from "./waves/gamePlan.js";

// Track which waves have already been triggered.
const triggeredWaves = new Set();

// Assume gameStartTime is set when the game starts.
let gameStartTime = performance.now();

// Update the spawn logic every second.
const waveSpawner = setInterval(() => {
  if (gameStarted && !document.hidden) {
    // Calculate elapsed seconds since game start.
    const elapsedSeconds = Math.floor((performance.now() - gameStartTime) / 1000);

    // Check if a wave is defined for the current elapsed seconds.
    // (Make sure the wave is only triggered once.)
    if (gamePlan.hasOwnProperty(elapsedSeconds.toString()) && !triggeredWaves.has(elapsedSeconds)) {
      triggeredWaves.add(elapsedSeconds);
      const wave = gamePlan[elapsedSeconds.toString()];
      
      // For each enemy group in this wave...
      wave.enemies.forEach(group => {
        // Spawn each enemy with the specified delay between spawns.
        for (let i = 0; i < group.count; i++) {
          setTimeout(() => {
            // For now, placement is just a placeholder.
            // You can use group.placement to modify the spawn position.
            if (group.type === "normal") {
              spawnEnemy({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, enemies });
            } else if (group.type === "squid") {
              spawnSquid({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, squids });
            } else if (group.type === "triangle") {
              spawnTriangleEnemy({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, triangleEnemies });
            }
          }, group.delay * i); // delay between each spawn in the group.
        }
      });
    }
  }
}, 1000);

    // Spawn initial enemies.
    for (let i = 0; i < 50; i++) {
      spawnEnemy({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, enemies });
    }
    for (let i = 0; i < 10; i++) {
      spawnSquid({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, squids });
    }
    for (let i = 0; i < 0; i++) {
      spawnTriangleEnemy({ physicsWorld, playerBody, worldWidth, worldHeight, enemyRadius, triangleEnemies });
    }

    // --- Input Handling ---
    const keys = { w: false, a: false, s: false, d: false };
    // Global variables for camera transition.
    let cameraMode = "full"; // "follow" or "full"
    let transitioning = false;
    let transitionStartTime = 0;
    const transitionDuration = 500; // in milliseconds
    let transitionStartOrigin = { x: 0, y: 0 };

    // These globals store the latest player position and scale so we can compute camera origins during toggles.
    let lastPlayerPos = playerBody.translation();
    let lastScale = canvas.width / worldWidth;

    window.addEventListener("keydown", (e) => {
      if (e.key === "w") keys.w = true;
      if (e.key === "a") keys.a = true;
      if (e.key === "s") keys.s = true;
      if (e.key === "d") keys.d = true;
      if (e.code === "Space") {
        if (!isDashing) {
          dashTriggered = true;
        }
        e.preventDefault();
      }
      if (e.key === "c") {
        // When toggling, set the transition's start origin as the current camera origin.
        transitionStartOrigin = getCameraOrigin_transition(lastPlayerPos, lastScale);
        // Toggle camera mode.
        cameraMode = (cameraMode === "follow") ? "full" : "follow";
        transitioning = true;
        transitionStartTime = performance.now();
      }
    });
    window.addEventListener("keyup", (e) => {
      if (e.key === "w") keys.w = false;
      if (e.key === "a") keys.a = false;
      if (e.key === "s") keys.s = false;
      if (e.key === "d") keys.d = false;
    });

    // Mouse tracking for aiming.
    let lastMouseX = 0;
    let lastMouseY = 0;
    let canvasRect = canvas.getBoundingClientRect();
    window.addEventListener("resize", () => {
      canvasRect = canvas.getBoundingClientRect();
    });
    canvas.addEventListener("mousemove", (e) => {
      lastMouseX = (e.clientX - canvasRect.left) * (canvas.width / canvasRect.width);
      lastMouseY = (e.clientY - canvasRect.top) * (canvas.height / canvasRect.height);
    });

    // Continuous firing and dash via mouse.
    canvas.addEventListener("mousedown", (e) => {
      if (e.button === 0) {
        isShooting = true;
      } else if (e.button === 2) {
        if (!isDashing) {
          dashTriggered = true;
        }
        e.preventDefault();
      }
    });
    canvas.addEventListener("mouseup", () => { isShooting = false; });
    canvas.addEventListener("mouseleave", () => { isShooting = false; });
    canvas.addEventListener("contextmenu", (e) => { e.preventDefault(); });

    // --- Camera Setup ---
    function getCameraScale() {
      return canvas.width / worldWidth;
    }
    // Follow mode: camera centered on the player.
    function getCameraOrigin_follow(playerPos, scale) {
      return {
        x: canvas.width / 2 - playerPos.x * scale,
        y: canvas.height / 2 - playerPos.y * scale,
      };
    }
    // Full mode: camera clamped to the game world boundaries.
    function getCameraOrigin_full(playerPos, scale) {
      const viewWidth = canvas.width / scale;
      const viewHeight = canvas.height / scale;
      let camX = playerPos.x - viewWidth / 2;
      let camY = playerPos.y - viewHeight / 2;
      const margin = 0;
      camX = Math.max(-margin, Math.min(camX, worldWidth - viewWidth + margin));
      camY = Math.max(-margin, Math.min(camY, worldHeight - viewHeight + margin));
      return {
        x: -camX * scale,
        y: -camY * scale
      };
    }
    // Transition mode: interpolates between the last recorded origin and the target origin over 0.5 seconds.
    function getCameraOrigin_transition(playerPos, scale) {
      if (!transitioning) {
        return (cameraMode === "follow")
          ? getCameraOrigin_follow(playerPos, scale)
          : getCameraOrigin_full(playerPos, scale);
      }
      const currentTime = performance.now();
      let progress = (currentTime - transitionStartTime) / transitionDuration;
      if (progress >= 1) {
        transitioning = false;
        return (cameraMode === "follow")
          ? getCameraOrigin_follow(playerPos, scale)
          : getCameraOrigin_full(playerPos, scale);
      }
      const targetOrigin = (cameraMode === "follow")
        ? getCameraOrigin_follow(playerPos, scale)
        : getCameraOrigin_full(playerPos, scale);
      return {
        x: transitionStartOrigin.x + (targetOrigin.x - transitionStartOrigin.x) * progress,
        y: transitionStartOrigin.y + (targetOrigin.y - transitionStartOrigin.y) * progress,
      };
    }
    const getCameraOrigin = getCameraOrigin_transition;

    // --- Revised Movement Logic for the Player ---
    const movementLerp = 0.2;
    let isDashing = false;
    function updatePlayerMovement(dt) {
      if (dashTriggered) {
        isDashing = true;
        setTimeout(() => { isDashing = false; }, 1000);
        const playerPos = playerBody.translation();
        const scale = getCameraScale();
        const origin = getCameraOrigin(playerPos, scale);
        const worldMouseX = (lastMouseX - origin.x) / scale;
        const worldMouseY = (lastMouseY - origin.y) / scale;
        const dx = worldMouseX - playerPos.x;
        const dy = worldMouseY - playerPos.y;
        const len = Math.hypot(dx, dy);
        if (len > 0) {
          const normX = dx / len;
          const normY = dy / len;
          const dashSpeed = 5000;
          playerBody.setLinvel({ x: normX * dashSpeed, y: normY * dashSpeed }, true);
        }
        dashTriggered = false;
        return;
      }
      const currentVel = playerBody.linvel();
      let targetVel = { x: 0, y: 0 };
      if (keys.w || keys.a || keys.s || keys.d) {
        let inputX = 0, inputY = 0;
        if (keys.w) inputY -= 1;
        if (keys.s) inputY += 1;
        if (keys.a) inputX -= 1;
        if (keys.d) inputX += 1;
        const len = Math.hypot(inputX, inputY);
        if (len > 0) {
          inputX /= len;
          inputY /= len;
        }
        targetVel.x = inputX * maxPlayerSpeed;
        targetVel.y = inputY * maxPlayerSpeed;
      }
      const newVel = {
        x: currentVel.x + (targetVel.x - currentVel.x) * movementLerp,
        y: currentVel.y + (targetVel.y - currentVel.y) * movementLerp,
      };
      playerBody.setLinvel(newVel, true);
    }

    // --- Modal and Game Start/Restart Logic ---
    let gameStarted = false;
    const modal = document.getElementById("modal");
    const modalContent = document.getElementById("modalContent");
    const beginButton = document.getElementById("beginButton");
    beginButton.addEventListener("click", () => {
      gameStarted = true;
      modal.style.display = "none";
    });
    function endGame() {
      gameStarted = false;
      modalContent.innerHTML = `
        <h1>Game Over</h1>
        <p>Your Score: ${score}</p>
        <button id="playAgain">Play Again</button>
      `;
      document.getElementById("playAgain").addEventListener("click", () => {
        location.reload();
      });
      modal.style.display = "flex";
    }

    // --- Fullscreen Button Functionality ---
    document.getElementById("fullscreenButton").addEventListener("click", () => {
      if (document.documentElement.requestFullscreen) {
        document.documentElement.requestFullscreen();
      } else if (document.documentElement.webkitRequestFullscreen) { /* Safari */
        document.documentElement.webkitRequestFullscreen();
      } else if (document.documentElement.msRequestFullscreen) { /* IE11 */
        document.documentElement.msRequestFullscreen();
      }
    });

    // --- Game Loop ---
    let lastTime = performance.now();
    let time = 0;
    function gameLoop(currentTime) {
      time += 16;
      if (!gameStarted) {
        requestAnimationFrame(gameLoop);
        return;
      }
      const dt = (currentTime - lastTime) / 1000;
      lastTime = currentTime;

      lastPlayerPos = playerBody.translation();
      lastScale = getCameraScale();

      updatePlayerMovement(dt);
      physicsWorld.step();

      updateEnemies(enemies);
      updateSquids(squids, playerBody, currentTime, dt);
      updateTriangleEnemies(triangleEnemies, playerBody, dt);

      for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        if (
          currentTime - bullet.birthTime > bulletLifetime ||
          bullet.body.translation().x < 0 ||
          bullet.body.translation().x > worldWidth ||
          bullet.body.translation().y < 0 ||
          bullet.body.translation().y > worldHeight
        ) {
          physicsWorld.removeRigidBody(bullet.body);
          bullets.splice(i, 1);
        }
      }

      const playerPos = playerBody.translation();
      for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        const bPos = bullet.body.translation();
        for (let j = enemies.length - 1; j >= 0; j--) {
          const enemy = enemies[j];
          const ePos = enemy.translation();
          if (Math.hypot(bPos.x - ePos.x, bPos.y - ePos.y) < bulletRadius + enemyRadius) {
            startBubbleExplosion(ePos.x, ePos.y);
            physicsWorld.removeRigidBody(enemy);
            enemies.splice(j, 1);
            physicsWorld.removeRigidBody(bullet.body);
            bullets.splice(i, 1);
            score += 10;
            break;
          }
        }
      }

      for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        const bPos = bullet.body.translation();
        for (let j = squids.length - 1; j >= 0; j--) {
          const squid = squids[j];
          const sPos = squid.translation();
          if (Math.hypot(bPos.x - sPos.x, bPos.y - sPos.y) < bulletRadius + enemyRadius) {
            startBubbleExplosion(sPos.x, sPos.y);
            physicsWorld.removeRigidBody(squid);
            squids.splice(j, 1);
            physicsWorld.removeRigidBody(bullet.body);
            bullets.splice(i, 1);
            score += 10;
            break;
          }
        }
      }

      for (let i = triangleEnemies.length - 1; i >= 0; i--) {
        const tri = triangleEnemies[i];
        const triPos = tri.translation();
        for (let j = bullets.length - 1; j >= 0; j--) {
          const bullet = bullets[j];
          const bPos = bullet.body.translation();
          if (Math.hypot(bPos.x - triPos.x, bPos.y - triPos.y) < bulletRadius + enemyRadius) {
            startBubbleExplosion(triPos.x, triPos.y);
            physicsWorld.removeRigidBody(tri);
            triangleEnemies.splice(i, 1);
            physicsWorld.removeRigidBody(bullet.body);
            bullets.splice(j, 1);
            score += 10;
            break;
          }
        }
      }

      for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        const ePos = enemy.translation();
        if (Math.hypot(playerPos.x - ePos.x, playerPos.y - ePos.y) < playerRadius + enemyRadius) {
          startBubbleExplosion(ePos.x, ePos.y);
          if (!isDashing) {
            playerHealth -= 10;
            startDamageExplosion(playerPos.x, playerPos.y);
          }
          physicsWorld.removeRigidBody(enemy);
          enemies.splice(i, 1);
          if (playerHealth <= 0) {
            endGame();
            return;
          }
        }
      }

      for (let i = squids.length - 1; i >= 0; i--) {
        const squid = squids[i];
        const sPos = squid.translation();
        if (Math.hypot(playerPos.x - sPos.x, playerPos.y - sPos.y) < playerRadius + enemyRadius) {
          startBubbleExplosion(sPos.x, sPos.y);
          if (!isDashing) {
            playerHealth -= 10;
            startDamageExplosion(playerPos.x, playerPos.y);
          }
          physicsWorld.removeRigidBody(squid);
          squids.splice(i, 1);
          if (playerHealth <= 0) {
            endGame();
            return;
          }
        }
      }

      for (let i = triangleEnemies.length - 1; i >= 0; i--) {
        const tri = triangleEnemies[i];
        const triPos = tri.translation();
        if (Math.hypot(playerPos.x - triPos.x, playerPos.y - triPos.y) < playerRadius + enemyRadius) {
          startBubbleExplosion(triPos.x, triPos.y);
          if (!isDashing) {
            playerHealth -= 10;
            startDamageExplosion(playerPos.x, playerPos.y);
          }
          physicsWorld.removeRigidBody(tri);
          triangleEnemies.splice(i, 1);
          if (playerHealth <= 0) {
            endGame();
            return;
          }
        }
      }

      if (isShooting && currentTime - lastShotTime > fireInterval) {
        lastShotTime = currentTime;
        const playerPos = playerBody.translation();
        const shipAngle = playerBody.rotation();
        const gunOffset = playerRadius + 10;
        const bulletStartX = playerPos.x + Math.cos(shipAngle) * gunOffset;
        const bulletStartY = playerPos.y + Math.sin(shipAngle) * gunOffset;
        const bulletBodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(bulletStartX, bulletStartY);
        const bulletBody = physicsWorld.createRigidBody(bulletBodyDesc);
        const bulletColliderDesc = RAPIER.ColliderDesc.ball(bulletRadius);
        physicsWorld.createCollider(bulletColliderDesc, bulletBody);
        bulletBody.setLinvel({
          x: Math.cos(shipAngle) * bulletSpeed,
          y: Math.sin(shipAngle) * bulletSpeed
        }, true);
        const soundClone = shotSound.cloneNode();
        soundClone.volume = 0.02;
        soundClone.play();
        bullets.push({ body: bulletBody, birthTime: currentTime });
      }

      if (lastMouseX || lastMouseY) {
        const scale = getCameraScale();
        const origin = getCameraOrigin(playerPos, scale);
        const worldMouseX = (lastMouseX - origin.x) / scale;
        const worldMouseY = (lastMouseY - origin.y) / scale;
        const targetAngle = Math.atan2(worldMouseY - playerPos.y, worldMouseX - playerPos.x);
        const currentAngle = playerBody.rotation();
        let angleDiff = Math.atan2(Math.sin(targetAngle - currentAngle), Math.cos(targetAngle - currentAngle));
        const angularPushFactor = 10;
        const angularVelocity = angleDiff * angularPushFactor;
        playerBody.setAngvel(angularVelocity, true);
      }

      renderScene({
        ctx,
        canvas,
        worldWidth,
        worldHeight,
        walls,
        playerBody,
        isDashing,
        playerRadius,
        enemies,
        enemyRadius,
        squids,
        triangleEnemies,
        bullets,
        bulletRadius,
        getCameraScale,
        getCameraOrigin,
        updateBubbleExplosions,
        updateDamageExplosions,
        time
      });

      document.getElementById("healthDiv").innerText = "Health: " + playerHealth + "% | Score: " + score;
      requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);
  </script>
</body>

</html>
